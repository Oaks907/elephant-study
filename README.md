[DOC]


郑刚《操作系统真相还原》实践代码
#### 重新运行需要更改 bochrc.disk 中的路径为决定路径，具体的查看 c1 文件夹中的 README.md 文件

## 知识记录
程序中各种数据结构的访问：该数据结构的起始地址 + 该数据结构所占用内存大小来实现

通用寄存器惯用法约定

| 寄存器 | 助记名称                       | 功能描述                                                                                                                                                                                              | 
|:----|:---------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ax  | 累加器（Accumulator）           | 使用频度较高，常用于算术运算、逻辑运算，保存与外设输入输出数据                                                                                                                                                                   |
| bx  | 基址寄存器（base）                | 常用来存在内存地址，以此地址作为基址，用来遍历一篇区域                                                                                                                                                                       |
| cx  | 计数器（counter）               | 计数器的作用用来计数，所以常用于循环指令中的循环次数                                                                                                                                                                        |
| dx  | 数据寄存器（data）                | 可用于存放数据，通常情况下只用于保存外设控制器的端口号地址                                                                                                                                                                     |
| si  | 源变址寄存器（source index）       | 常用于字符串操作中的数据源地址，既被传送的数据在哪里。通常与其他指令配合使用，如批量数据传送指令族 movs[bwd]                                                                                                                                       |
| di  | 目的变址寄存器（destination index） | 和si一样，常用于字符串操作。但di是用于数据的目的地址                                                                                                                                                                      |
| sp  | 栈指针寄存器（stack pointer）      | 其段基址是SS，用来指向栈顶。随着栈中数据的进出，push、pop操作会修改sp的值                                                                                                                                                        |
| bp  | 基址寄存器（base pointer）        | 访问栈有两种方式，一种是push、pop指令操作栈，sp指针的值会自动更新，但我们只能获取到栈顶sp指针指向的数据。很多时候，我们需要读写在栈顶与栈底之间的数据。处理器为了让开发人员方便控制栈中数据，还提供了把栈当成数据段来访问的方式，既提供了寄存器bp，所以bp默认的寄存器就是SS，可通过SS:bp的方式将栈当作普通的数据段来访问，只不过bp不像sp那样随着push、pop自动改变 |

##指令

CPU前进的方向永远是 CS：IP这，两个寄存器，CS寄存器是代码段段基址，IP寄存器是代码段的段内偏移地址，CS * 16 + IP 就是CPU执行指令的内存地址。

ret: 在栈顶（寄存器ss:sp所指向的地址）弹出2字节的内容来替换IP寄存器，ret指令不管里面的内容是什么，它只负责将当前栈顶的内容弹出栈，并用他为IP寄存器赋值。

ref：同上，不过是弹出4字节

call：call指令会在栈中留下返回地址（IP寄存器的值）

## Bochs常用调试命令

| 作用                | 命令            | 示例                |
|:------------------|:--------------|:------------------|
| 在某物理地址设置断点        | 	b addr       | 	b 0x7c00         |
| 显示当前所有断点信息        | 	info break   | 	info break       |
| 继续执行，直至遇到断点       | 	c            | 	c                |
| 单步执行	             | s	            | s                 |
| 单步执行（遇到函数跳过）      | 	n            | 	n                |
| 查看寄存器信息	          |               |                   |
| 查看堆栈              | 	print-stack  | 	print-stack      |
| 查看内存物理地址内容        | 	xp /nuf addr | 	xp /40bx 0x9013e |
| 查看线性地址内容	         | x /nuf addr   | 	x /40bx 0x13e    |
| 反汇编一段内存           | 	u start end	 | u 0x30400 0x3040d |
| 反汇编执行的每一条指令	      | trace-on	     | trace-on          |
| 每执行一条指令就打印 CPU 信息 | 	trace-reg    | 	trace-reg        |

## 函数调用

```shell
int subtract（int a, int b）; // 被调用者
int sub = subtract(3, 2); // 主调用者
```

主调用者：
```shell
; 从右至左将参数入栈
push 2
push 3
call substract
add esp, 8
```

被调用者
```shell
push ebp
mov ebp, esp
mov eax,[ebp + 0x8]
add eax,[ebp + 0xc]

mov esp, ebp

pop ebp
ret
```



